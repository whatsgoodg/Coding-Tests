# Comparison Sort
삽입정렬은 자료구조에 삽입을 하며 정렬을 진행하는 것이다. PS에서는 사용될 일이 없으니 건너뛰는게 더 나아보인다.     
## 선택정렬
선택정렬은 삽입정렬과 다르게 이미 자료구조에 있는 데이터를 정렬하는 것이다.
용어는 몰랐더라도 항상 사용하던 그 정렬이다. N개의 데이터가 배열에 있을 때, 맨 마지막 인덱스의 원소를 기준으로 나머지 원소들과 비교한다.     
나머지 원소들중 가장 큰 원소를 찾았다면 맨 마지막의 인덱스에 삽입한다. 
맨 마지막 원소 1개를 기준으로 N-1개의 나머지 원소들을 탐색하고, 맨 마지막부터 맨 처음(1번째)원소까지 이를 진행한다면 ***O(N^2)*** 의 시간복잡도를 가진다.         
***source code***      
```cpp  
  int arr[10]{ 3,2,7,116,62,235,1,23,55,77 };
  int N = 10;
  for (int i = N - 1; i > 0; i++) {
	int mxidx = 0;// 0부터 시작
	for (int j = 1; j <= i; j++) {// 0부터 맨 끝자리 까지
		if (arr[mxidx] < arr[j]) mxidx = j;
	}
	swap(arr[mxidx], arr[i]);// 가장 큰 수를 마지막 자리와 교체
  }
```      
주석만 봐도 이해하기 수월할 것이다.     
## 버블정렬
버블정렬이 선택정렬보다 구현하기 더 편하고 시간복잡도도 같다.    
> 1. 인덱스의 인접해 있는 두 원소를 비교하여 조건에 맞게 swap한다.
> 2. 1번을 맨 앞의 원소부터 시작하여 맨 마지막 이전원소까지 탐색을 한다.     
      
{2 13 6 4 -2} 원소를 가진 배열이 있다. 2부터 시작하여 버블정렬을 진행한다면 이런 결과가 나올 것이다.       
      
> 1. {2 13 6 4 -2}      
> 2. {2 6 13 4 -2}      
> 3. {2 6 4 13 -2}      
> 4. {2 6 4 -2 13}      
       
이렇게 N-1번 인접한 원소끼리 비교를 하며 swap을 한 번 했을 때의 결과이다. 가장 큰 수가 첫 번째로 맨 마지막에 위치한다.        
이를 위해, 총 N - 1번의 비교와 swap이 필요하며 이를 N - 1개의 원소에 모두 행해져야 한다.           
(N - 1) * (N - 1)번으로 버블정렬도 ***O(N^2)*** 의 시간복잡도를 가진다.      
***source code***     
```cpp
  int arr[5]{ 2, 13, 6, 4, -2 };
  int N = 15;
  for (int i = 0; i < N; i++) {
        for (int j = 0; j < N - 1 - i; j++) {
	if (arr[j] > arr[j + 1]) swap(arr[i], arr[j + 1]);
	}
  }
```

## 합병정렬     
합병정렬은 재귀적으로 수열을 나눠 정렬한 후 합치는 정렬이다.       
왜 재귀적이냐면, 하나의 배열을 합병정렬할 때, 모든 배열을 계속해서 반으로 나눈다. N 크기의 배열이 존재한다면 크기를 2로 나눈다.   
계속 나눠 N개의 배열 즉, 하나의 원소만 가지고 있는 배열이 N개가 만들어졌을 때 합벙정렬을 진행한다.     
그 이후의 배열을 합병하며 정렬을 한다. 크기 1인 배열 N개가 있을 때 이를 각각 크기 2인 배열로 합병하며 정렬을 한다.     
크기 2인 배열들을 합병하며 정렬한다. 재귀적으로 다시 크기 N인 배열이 만들어진다.     
심지어 코드도 굉장히 간단하다.    
***source code***
```cpp
int n = 10;
int arr[10];
int tmp[10];
void merge(int st, int en) {
     int mid = (st + en) / 2;
     int lidx = st;
     int ridx = mid;
     for (int i = st; i < en; i++) {
	   if (ridx == en) tmp[i] = arr[lidx++]; //(6)
	   else if (lidx == mid) tmp[i] = arr[ridx++]; //(6)
	   else if (arr[lidx] <= arr[ridx]) tmp[i] = arr[lidx++]; //(7)
	   else tmp[i] = arr[ridx]++; //(7)
     }
     for (int i = st; i < en; i++) arr[i] = tmp[i];
}
void merge_sort(int st, int en) { 
     if (en == st + 1) return; //(4)
     int mid = (st + en) / 2; //(1)
     merge_sort(st, mid); //(2)
     merge_sort(mid, en); //(3)
     merge(st, en); //(5)
}
```      
> * (1). 배열을 반으로 나눠준다.
> * (2),(3) 반으로 나눈 두 배열을 재귀함수를 호출하여 반으로 나눠준다.
> * (4) 크기가 1인 배열이 N개 만들어졌을 때, 이들은 이미 정렬이 된 것이니 재귀함수를 종료한다
> * (5) 배열의 합병을 N이 1일 때 부터 시작한다.      
> * (6) merge 함수에서 두 배열의 맨 앞 원소를 비교하며 둘 중 작은 순으로 합병한다.()      
> * (7) 둘 중 하나의 배열이 비어있다면, 나머지 하나의 배열의 모든 원소를 순서대로 넣어주면 된다.(각각의 배열은 이미 정렬이 되어있다.)     
       
(7)을 보면, 만약 원소의 크기가 같을 때 두 개의 배열 중 왼쪽 즉, st부터 mid까지의 배열의 원소가 먼저 들어가는 것을 볼 수 있다.   
이 이유는 합병정렬이 ***Stable Sort***이기 때문이다. 직역하면 안정된 정렬인데 이는 맨 처음에 있던 순서를 그대로 지켜준다는 뜻이 된다.     
정렬을 위한 기준이 숫자밖에 없다면 앞의 배열이나 뒤의 배열, 둘 중 어디에서나 들어가도 상관없을 것이다.      
그런데 만약 key와 value가 있는 pair상태의 데이터를 정렬할 때, key의 오름차순으로 정렬을 시도하고 나서 같은 key를 가진 데이터를 확인한다면      
이들은 정렬되기 이전의 순서를 유지하고 있을 것이다.    
예를 들어 { {1,2}, {2,3}, {1,4} }를 정렬하고 싶을 때, 왼쪽의 정수를 기준으로 합병정렬을 진행했을 때 { {1,2}, {1,4}, {2,3} } 이러한 결과가 나온다.   
{1,2}와 {1,4}는 정렬 이전의 순서를 그대로 따라간다.          
## 퀵 소트      




