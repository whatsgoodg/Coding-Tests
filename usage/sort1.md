# Comparison Sort
삽입정렬은 자료구조에 삽입을 하며 정렬을 진행하는 것이다. PS에서는 사용될 일이 없으니 건너뛰는게 더 나아보인다.     
## 선택정렬
선택정렬은 삽입정렬과 다르게 이미 자료구조에 있는 데이터를 정렬하는 것이다.
용어는 몰랐더라도 항상 사용하던 그 정렬이다. N개의 데이터가 배열에 있을 때, 맨 마지막 인덱스의 원소를 기준으로 나머지 원소들과 비교한다.     
나머지 원소들중 가장 큰 원소를 찾았다면 맨 마지막의 인덱스에 삽입한다. 
맨 마지막 원소 1개를 기준으로 N-1개의 나머지 원소들을 탐색했고, 맨 마지막부터 맨 처음(1번째)원소까지 이를 진행한다면 
N * (N - 1 - 2 - 3...)이므로 ***O(N^2)*** 의 시간복잡도를 가진다.     
코드로 확인해보자 
```cpp  
  int arr[10]{ 3,2,7,116,62,235,1,23,55,77 };
	int N = 10;
	for (int i = N - 1; i > 0; i++) {
		int mxidx = 0;// 0부터 시작
		for (int j = 1; j <= i; j++) {// 0부터 맨 끝자리 까지
			if (arr[mxidx] < arr[j]) mxidx = j;
		}
		swap(arr[mxidx], arr[i]);// 가장 큰 수를 마지막 자리와 교체
	}
```      
주석만 봐도 이해하기 수월할 것이다.     
## 버블정렬
버블정렬이 선택정렬보다 구현하기 더 편하고 시간복잡도도 같다.    
> 1. 인덱스의 인접해 있는 두 원소를 비교하여 조건에 맞게 swap한다.
> 2. 1번을 맨 앞의 원소부터 시작하여 맨 마지막 이전원소까지 탐색을 한다. 
{2 13 6 4 -2} 원소를 가진 배열이 있다. 2부터 시작하여 버블정렬을 진행한다면 이런 결과가 나올 것이다.     
> 1. {2 13 6 4 -2}
> 2. {2 6 13 4 -2}
> 3. {2 6 4 13 -2}
> 4. {2 6 4 -2 13}
이렇게 N-1번 인접한 원소끼리 비교를 하며 swap을 한 번 했을 때의 결과이다. 총 N - 1번의 비교와 swap이 필요하며 N - 1번의 동작이 필요하다.      
(N - 1) * (N - 1)번으로 버블정렬도 ***O(N^2)*** 의 시간복잡도를 가진다.
