# Comparison Sort
***Comparison sort***: 자료구조 내의 원소들을 비교하며 정렬하는 것을 뜻한다.      
이 정렬 기법중 하나인 삽입정렬은 자료구조에 삽입을 하며 정렬을 진행하는 것이다. PS에서는 사용될 일이 없으니 건너뛰겠다.      
***In-place sort***: 정렬을 행할 때 무시할만한 저장공간만 더 사용하는 정렬 알고리즘을 뜻한다.       
대개 하나의 배열을 정렬할 때, 배열 하나가 더 필요하다면 In-place sort가 아니다.      
## 선택정렬      
선택정렬은 삽입정렬과 다르게 이미 자료구조에 있는 데이터를 정렬하는 것이다.
용어는 몰랐더라도 항상 사용하던 그 정렬이다. N개의 데이터가 배열에 있을 때, 맨 마지막 인덱스의 원소를 기준으로 나머지 원소들과 비교한다.     
나머지 원소들중 가장 큰 원소를 찾았다면 맨 마지막의 인덱스에 삽입한다. 
### 시간복잡도
인덱스 N-1번째 원소 1개를 기준으로 나머지 원소들과 비교하면 N-1번이 걸린다. 기 이후 N-2번째와 나머지 원소들은 N-2번이 걸릴 것이다.
이 행위를 N-1번째 인덱스부터 맨 처음(인덱스 1)원소까지 진행한다면 N-1번이니 ***O(N^2)*** 의 시간복잡도를 가진다.         
***source code***      
```cpp  
  int arr[10]{ 3,2,7,116,62,235,1,23,55,77 };
  int N = 10;
  for (int i = N - 1; i > 0; i++) {
	int mxidx = 0;// 0부터 시작
	for (int j = 1; j <= i; j++) {// 0부터 맨 끝자리 까지
		if (arr[mxidx] < arr[j]) mxidx = j;
	}
	swap(arr[mxidx], arr[i]);// 가장 큰 수를 마지막 자리와 교체
  }
```      
주석만 봐도 이해하기 수월할 것이다.     
## 버블정렬
버블정렬이 선택정렬보다 구현하기 더 편하고 시간복잡도도 같다.    
> 1. 인덱스의 인접해 있는 두 원소를 비교하여 조건에 맞게 swap한다.
> 2. 1번을 맨 앞의 원소부터 시작하여 맨 마지막 이전원소까지 탐색을 한다.     
      
{2 13 6 4 -2} 원소를 가진 배열이 있다. 2부터 시작하여 버블정렬을 진행한다면 이런 결과가 나올 것이다.       
      
> 1. {2 13 6 4 -2}      
> 2. {2 6 13 4 -2}      
> 3. {2 6 4 13 -2}      
> 4. {2 6 4 -2 13}      
                  
### 시간복잡도
이렇게 N-1번 인접한 원소끼리 비교를 하며 swap을 한 번 했을 때의 결과이다. 가장 큰 수가 첫 번째로 맨 마지막에 위치한다.        
이를 위해, 총 N - 1번의 비교와 swap이 필요하며 이를 N - 1개의 원소에 모두 행해져야 한다.           
버블정렬도 삽입정렬과 비슷하게 ***O(N^2) 시간복잡도***를 가진다.      
***source code***     
```cpp
  int arr[5]{ 2, 13, 6, 4, -2 };
  int N = 15;
  for (int i = 0; i < N; i++) {
        for (int j = 0; j < N - 1 - i; j++) {
	if (arr[j] > arr[j + 1]) swap(arr[i], arr[j + 1]);
	}
  }
```

## 합병정렬     
합병정렬은 재귀적으로 수열을 나눠 정렬한 후 합치는 정렬이다.       
왜 재귀적이냐면, 하나의 배열을 합병정렬할 때, 모든 배열을 계속해서 반으로 나눈다. N 크기의 배열이 존재한다면 크기를 2로 나눈다.   
계속 나눠 N개의 배열 즉, 하나의 원소만 가지고 있는 배열이 N개가 만들어졌을 때 합벙정렬을 진행한다.     
그 이후의 배열을 합병하며 정렬을 한다. 크기 1인 배열 N개가 있을 때 이를 각각 크기 2인 배열로 합병하며 정렬을 한다.     
크기 2인 배열들을 합병하며 정렬한다. 재귀적으로 다시 크기 N인 배열이 만들어진다.     
심지어 코드도 굉장히 간단하다.    
***source code***
```cpp
int n = 10;
int arr[10];
int tmp[10];
void merge(int st, int en) {
     int mid = (st + en) / 2;
     int lidx = st;
     int ridx = mid;
     for (int i = st; i < en; i++) {
	   if (ridx == en) tmp[i] = arr[lidx++]; //(6)
	   else if (lidx == mid) tmp[i] = arr[ridx++]; //(6)
	   else if (arr[lidx] <= arr[ridx]) tmp[i] = arr[lidx++]; //(7)
	   else tmp[i] = arr[ridx]++; //(7)
     }
     for (int i = st; i < en; i++) arr[i] = tmp[i];
}
void merge_sort(int st, int en) { 
     if (en == st + 1) return; //(4)
     int mid = (st + en) / 2; //(1)
     merge_sort(st, mid); //(2)
     merge_sort(mid, en); //(3)
     merge(st, en); //(5)
}
```              
> * (1). 배열을 반으로 나눠준다.             
> * (2),(3) 반으로 나눈 두 배열을 재귀함수를 호출하여 반으로 나눠준다.                
> * (4) 크기가 1인 배열이 N개 만들어졌을 때, 이들은 이미 정렬이 된 것이니 재귀함수를 종료한다               
> * (5) 배열의 합병을 N이 1일 때 부터 시작한다.                
> * (6) merge 함수에서 두 배열의 맨 앞 원소를 비교하며 둘 중 작은 순으로 합병한다.                   
> * (7) 둘 중 하나의 배열이 비어있다면, 나머지 하나의 배열의 모든 원소를 순서대로 넣어주면 된다.(각각의 배열은 이미 정렬이 되어있다.)                   
                     
(7)을 보면, 만약 원소의 크기가 같을 때 두 개의 배열 중 왼쪽 즉, st부터 mid까지의 배열의 원소가 먼저 들어가는 것을 볼 수 있다.                
이 이유는 합병정렬이 ***Stable Sort***이기 때문이다. 직역하면 안정된 정렬인데 이는 맨 처음에 있던 순서를 그대로 지켜준다는 뜻이 된다.           
정렬을 위한 기준이 숫자밖에 없다면 앞의 배열이나 뒤의 배열, 둘 중 어디에서나 들어가도 상관없을 것이다.           
그런데 만약 key와 value가 있는 pair상태의 데이터를 정렬할 때 key의 오름차순으로 정렬을 시도하고 나서 같은 key를 가진 데이터를 확인한다면 이들은 정렬되기 이전의 순서를 유지하고 있을 것이다.                       
예를 들어 { {1,2}, {2,3}, {1,4} }를 정렬하고 싶을 때, 왼쪽의 정수를 기준으로 합병정렬을 진행했을 때 { {1,2}, {1,4}, {2,3} } 이러한 결과가 나온다.         
{1,2}와 {1,4}는 정렬 이전의 순서를 그대로 따라간다.              
### 시간복잡도(N = 2^k)                 
배열을 분할하는 과정에서의 시간복잡도는 배열을 두 개, 네 개, 여덟 개로 나뉜다. 그렇다면 (2 + 4 + 8 ... + 2^k = 2N - 1)이므로 O(N)이다.          
다음으로 합병할 때이다. 합병할 때는 모든 원소가 비교되며 합쳐지기 때문에 N번 걸린다.                
배열의 크기가 1일 때, 모든 1인 크기의 배열이 크기가 2로 합쳐진다. 이 때 모든 원소드들을 비교하며 합병되기 때문에 N번의 연산이 일어난다.         
그 이후 크기가 1인 배열에서 2^k(=N) 크기의 배열이 될 때 까지 총 k번의 연산(크기가 두 배씩 커진다)이 일어난다.           
그렇다 면 ***O(NK) = O(NlogN)*** 시간복잡도를 가지게 된다.        
                 
## 퀵소트            
퀵소트는 거의 제일 빠르기에 대개 라이브러리의 정렬 알고리즘들은 퀵소트를 기반으로 만들어져있다.           
퀵소트도 합병정렬처럼 재귀적으로 구현되는 정렬 알고리즘이다. 퀵소트는 pivot이란 배열안의 원소 하나가 필요하다.            
이 pivot은 배열 맨 왼쪽에 위치한다. 그리고 l, r포인터가 pivot이후에 맨 왼쪽, 맨 오른쪽 원소를 가리키는 포인터이다.       
l은 pivot보다 큰 값이 나올 때까지 오른쪽으로 이동한다. r은 pivot보다 작은 값이 나올 때까지 왼쪽으로 이동한다.        
그리고 l과 r을 스왑한다. 그리고 l과 r이 교차할 때, 즉 r이 l보다 왼쪽에 있다면 pivot과 r을 스왑하고 끝난다.        
***source code***          
```cpp         
void quick_sort(int st, int en) { // arr[st to en-1]을 정렬할 예정
  if(en <= st+1) return; // 수열의 길이가 1 이하이면 함수 종료. 
  int pivot = arr[st]; // pivot(맨 앞의 원소) 임의의 값을 잡고 arr[st]와 swap해도 상관없음.
  int l = st+1; // 포인터 l
  int r = en-1; // 포인터 r
  while(1){
    while(l <= r && arr[l] <= pivot) l++;
    while(l <= r && arr[r] >= pivot) r--;
    if(l > r) break; // l과 r이 역전되는 그 즉시 탈출
    swap(arr[l], arr[r]);
  }
  swap(arr[st], arr[r]);
  quick_sort(st, r); //r을 기준으로 배열 나누고 퀵소트(합병정렬과 비슷하다.)
  quick_sort(r+1, en); //r을 기준으로 배열을 나누고 퀵소트(합병정렬과 비슷하다.)
}
```        
### 시간복잡도         
pivot이 계속해서 배열의 중간에 도달한다면 합병정렬과 같이 크기 N의 배열을 반으로 나눌 것이기 때문에 O(NlogN)이 걸릴 것이다.         
어느정도 자리만 잘 잡는다 해도 ***O(NlogN)*** 이 걸릴 것이다.         
하지만 굉장히 치명적인 단점이 있다. 만약 이미 완벽하게 정렬되어 있는 배열 {1, 2, 3, 4, 5, 6, 7}을 퀵소트로 정렬할 때를 보자.         
그렇다면 1이 pivot이 되고, l과 r은 교차할 때까지 반복을 하다 스왑없이 반복문이 종료될 것이다.         
그렇다면 모든 원소를 돌며 스왑없이 l과 r이 교차될 때까지 반복되며 이는 ***O(N^2)*** 라는 시간복잡도를 가지게 된다.         
                 
## 합병정렬 vs 퀵소트     
퀵소트의 이러한 이유 때문에 STL을 사용할 수 없다면 무조건 O(NlogN)이 나오는 합병정렬을 구현하여 사용하는게 바람직하다.       
하지만 STL의 sort도 퀵소트를 기반으로 만들어진 함수이다. 이는 직접구현하는 퀵소트와 다르게 최악의 상황에서도 O(NlogN)을 보장한다.       
일정깊이 이상으로 들어간다면 힙소트로 정렬하기 때문이다. 이러한 정렬을 Introspective sort라고 한다.      



