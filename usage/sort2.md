# Non-comparison sort        
***Non-comparison sort***: Comparison sort와 다르게 원소들을 비교하지 않고 정렬하는 것이다.           
## Counting sort        
수가 작을 때, 512mb 기준으로 대략 크기 1.2억의 int타입 배열을 잡을 수 있으니 크기가 작은 배열을 다룰 때 사용하는 정렬이다.        
[배열](https://github.com/whatsgoodg/PS/blob/main/usage/array.md) 사용법이랑 똑같다. {3, 3, 4, 6, 7, 7, 2} 크기 7의 배열이 있을 때, (배열의 가장 큰 수 + 1)을 크기로 가지는 배열을 따로 이용해서 정렬을 하는 것이다.         
          
### source code        
```cpp   
int arr[7]{ 3, 3, 4, 6, 7, 7, 2 };
int nums[8]{ 0, 0, 1, 2, 1, 0, 1, 2 }; //arr 의 값들로 nums를 인덱싱하여 원소 개수를 센다.
for (int i = 0; i < 8; i++) {
   while (nums[i]--) std::cout << i << ' ';// 개수만큼 원소 출력 개수가 0이되면 반복문 종료
}
```     
***문제*** [15688](https://www.acmicpc.net/problem/15688)            
                
## Radix sort        
counting sort를 응용한 정렬 알고리즘이다. 크기 10의 리스트가 필요하다. 0~9를 인덱스로 가지는 배열을 이용하여 정렬을 진행한다.         
{12, 421, 46, 674, 103, 502, 7, 100, 21, 545, 722, 227, 62, 91, 240} 배열이 있을 때, 일의 자리로 크기 10의 배열을 인덱싱하여 수를 저장한다.       
그 이후로 십의 자리, 백의 자리까지 모두 정렬을 한다면 정렬이 완료된다.       
이 원리는 421과 502을 보았을 때. 맨 처음 상황은 421이 맨 왼쪽에 있고 일의 자리를 기준으로 정렬을 한다면 421이 여전히 왼쪽에 있을 것이다.         
십의 자리인 경우엔 2가 0보다 크니 502가 왼쪽에 있을 것이다. 이후에 백의 자리인 경우엔 5가 4보다 더 크니 502가 오른쪽에 있을 것이다.        
이 경우도 같은 값이라면 왼쪽에 있던 값이 정렬 이후에도 왼쪽에 위치할 것이다.         
### 시간복잡도         
자리 수의 개수가 D라면 이를 자리 수마다 저장하기 위한 배열의 개수를 K개라고 할 때 시간복잡도는 ***O(D(N + K))*** 이다.        
그런데 리스트의 개수는 N에 비해 비교할 수 있을 정도로 작기 때문에, O(DN)이다.      
[***source code***](https://github.com/encrypted-def/basic-algo-lecture/blob/master/0x0F/radix_sort.cpp)      

