# 우선순위 큐              
우선순위 큐란 원소 제거 시 우선순위가 가장 높은 원소가 제거되는 자료구조이다.                   
우선순위 큐를 구현하는 [힙]()을 이 포스트전에 확인하자.           
                 
## 구현(최소힙)              
구현이 굉장히 간단하므로 조건을 확인하고 구현해보자.              
배열로 구현하며 index 1이 root 노드이다. 각 노드의 왼쪽 자식은 **node index * 2**, 오른쪽 자식은 **node index * 2 + 1**이다.              
>* **push**: 배열로 구현하기 때문에, 부모자식의 관계를 만족하는 힙의 크기를 인덱스로 사용한다. 이후 upheap 해준다.                    
>* **pop**: root 노드를 삭제하기 위해 맨 마지막 노드와 교환 후, downheap을 해준다. (자식의 크기가 같을 경우 왼쪽을 선택한다.)             
                             
[**구현코드**](https://github.com/whatsgoodg/PS/blob/main/PQ/PQ_with_array.cpp)                    
[STL](https://github.com/whatsgoodg/PS/blob/main/PQ/PQ%20_with_STL.cpp)                    
                   
## set과의 차이
사실상 set이 우선순위 큐의 모든 기능을 제공해준다 하지만 우선순위 큐가 더 빠르다.(시간 복잡도 2~4배, 공간 복잡도 차이도 존재)          
set은 레드블랙트리를 기반으로 한 자료구조이므로 삽입, 삭제 시 불균형 문제를 계속해서 해결해야한다.               
그렇다면 set을 사용해야할 때는, 모든값을 정렬하면서 특정 수와의 대소관계를 통한 find를 lgN 시간복잡도로 사용해야할 때이다.(lower_bound, upper_bound)           
만약 값을 지속적으로 삽입하며 최소, 최대 혹은 어떤 우선순위로 원소를 계속해서 확인하거나 삭제만을 요구한다면 우선순위 큐가 더 유리할 것이다.                   
                  
