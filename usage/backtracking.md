# 백트래킹
백트래킹이란 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하는 알고리즘이다.        
이렇게만 듣는다면 완전탐색인 부르트포스랑 차이점이 없어 보인다. 그러나 용어에서 보았을 때 백트래킹은 이전상태(back)를 추적한다.(tracking)         
이전상태로 돌아가는 행위를 ***가지치기***라고 부른다.        
그렇다면 백트래킹은 완점탐색을 하던 도중에 결과와 맞지 않는 경우의 수가 등장했을 경우 탐색을 중단한다.         
        
### 백트래킹의 성질     
> 1. 모든 경우의 수를 탐색한다.      
> 2. 모든 경우의 수를 탐색하던 도중 결과와 맞지 않는 조건에 해당되면 탐색을 즉시 종료하고 이전 상태로 돌아간다.       
               
부르트포스 알고리즘은 BFS, DFS, 선형 자료구조 등 다양하게 구현될 수 있고 사용될 수 있다. 그냥 완전탐색을 한다면 그건 부르트 포싱인 것이다.        
그런데 만약 완전탐색에 가지치기를 더한다면 어떻게 구현을 해야할까?        
      
### 가지치기      
백트래킹은 완전탐색 도중 가지치기를 한다. 이는 결과와 적합하지 않다면, 즉시 탐색을 중단하고 이전 상태로 돌아가 또 다른 경우의 수를 탐색한다.       
이는 DFS와 비슷해 보인다. Stack을 이용한 DFS를 본다면 하나의 경우의 수(한 방향의 깊이)를 탐색하다가 그 방향의 탐색이 끝났을 경우     
그 이전의 다른 방향을 탐색하는 성질을 가진다. 이는 완전탐색을 DFS로 구현한 경우이며 우리가 흔히 아는 부르트포스 알고리즘이다.            
그렇다면 이런 결과가 나오게 된다.                  
> * DFS는 백트래킹-가지치기(부르트포스) 형태이다.                              
> ***결론적으로 DFS에 탐색 조건을 추가한다면 백트래킹 알고리즘이 되는 것이다.***                       
          
<br><br>
## 시간복잡도                             
DFS말고 백트래킹을 사용하는 이유가 무엇일까?                       
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2c/Depthfirst.png/250px-Depthfirst.png"  width="400" height="300"/>      
이는 DFS의 이미지이며, 트리의 한 방향을 우선 탐색하는 것을 볼 수 있다. 탐색이 끝났을 경우 그 깊이에서의 모든 조건을 탐색하기 위해      
같은 깊이의 다음 노드를 탐색하는 것을 볼 수 있다. 위의 이미지처럼 tree의 가장 깊은 깊이에 도달했을 때 탐색을 끝낸다면 시간복잡도가 굉장히 클 수 있다.                 
완전탐색에서 시간복잡도를 줄이기 위해 백트래킹을 사용한다.       
백트래킹을 사용한다면 위의 이미지에서 깊이 2의 가장 왼쪽에 있는 노드가 조건에 부합하지 않는다면 탐색을 바로 종료하고 그 이전으로 돌아간다.      
하지만 최악의 경우 모든 경우의 수를 돌아보기 때문에 시간복잡도가 더 낮다고 말할 수 없다.       
          
## 응용문제       
DFS는 대개 재귀함수로 구현된다.     
### [부분수열의 합](https://www.acmicpc.net/status?from_mine=1&problem_id=1182&user_id=rlwjddl234&language_id=1001)          
N개의 부분수열이 주어지고 이 0~N개의 부분수열 중에 부분수열의 합이 S가 나오는 부분수열의 개수를 구하는 문제이다.         
그렇다면 우리는 0개의 부분수열부터 N개까지의 부분수열의 모든 경우의 수를 봐야한다. 왜냐하면 부분수열의 합을 따져야하는 문제이기에                   
모든 경우의 수를 확인해봐야한다. 부분수열을 보는 특정 경우의 수가 0이 아니라는 가능성을 파악할 수가 없고 모든 경우의 수를 따져봐야                 
0이 될 수 있는지 없는지를 판단할 수 있다.                      
그렇다면 이 문제는 부르트포스 알고리즘이다. DFS를 이용하여 모든 경우의 수를 확인한다.                             
***source code***                     
```cpp                         
void subsequence(int n, int sum) {
	if (n == N) {
		if (sum == S) ans++;
		return;
	}
	subsequence(n + 1, sum);//부분수열에 해당 값이 포함되는 경우
	subsequence(n + 1, sum + sequence[n]);//부분수열에 해당 값이 포함되지 않는 경우
}
```       
> * 주어지는 수열을 배열(sequence)에 저장하고 처음 함수 호출을 0(깊이)로 둔다.                       
> * 원래 수열이 부분수열에 포함되는 경우와 그렇지 않는 경우를 모두 호출한다.(시간 복잡도 O(2^N))                      
> * Base condition을 원래 수열의 크기로 둔다.(모든 경우의 수를 탐색)                     

### [N과 M (1)](https://www.acmicpc.net/problem/15649)                   
자연수 N(1~N 수열)이 주어졌을 때 자연수 M의 길이의 중복되지 않는 사전순으로 증가하는 부분 수열을 만들어야 하는 문제이다.                   
사전순으로 출력을 해야하는 것은 반복문으로 간단하게 해결할 수 있을 것이다.                  
중요한건 중복되는 값이 들어오면 안 된다는 것이다. 위의 문제와 달리 더하는 것이 아니라 부분수열을 선택하는 문제이기 때문에              
모든 경우의 수가 아니라 중복되는 수를 맞딱 뜨렸을 때 백트래킹을 하면 되기 때문에, 완전탐색(중복 포함)보다 시간복잡도가 더 낮아질 것이다.               
***source code***                  
```cpp           
int arr[9];
bool visited[9];
void func(int n) {
	if (n == M) {
		for (int i = 0; i < M; i++) {
			cout << arr[i] << ' ';
		}
		cout << '\n';
		return;
	}
	for (int i = 1; i <= N; i++) {
		if (visited[i]) continue; //백트래킹
		arr[n] = i;//현재 경우의 수 탐색
		visited[i] = 1;//탐색 mark
		func(n + 1); //다음 경우의 수 탐색
		visited[i] = 0; //현재 경우의 수 탐색 종료 
	}
}
```     
> * visited 배열을 이용하여 중복을 막아준다. 만약 visited가 1일 경우 해당 경우의 수는 중복되었기 때문에 이전으로 돌아가 다음 경우의 수를 확인한다.          
> * 탐색이 종료되었을 경우 visited를 0으로 바꾸어 다음 경우의 수에서 탐색이 가능하게 한다.                 
> * M개의 수가 모였을 경우 해당 결과를 출력한다.                      


번외) BFS구현, 재귀와 반복문의 차이





